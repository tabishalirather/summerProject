import time
from collections import Counter
from itertools import permutations, zip_longest

import sympy as sp

var_list = [0, sp.Symbol('w'), sp.Symbol('x'), sp.Symbol('y'), sp.Symbol('z'), sp.Symbol('a')]


def calculate_integrals_sum(limits_tuple):
    unique_limits_integral_value_dict = make_unique_value_dict(limits_tuple)
    grouped_limit_tuple = get_tuple_of_grouped_limits_tuple(limits_tuple)
    limits_counter = Counter(grouped_limit_tuple)
    print(f"Count is {limits_counter}")
    result = sum(unique_limits_integral_value_dict[k] for k in grouped_limit_tuple)
    print(f"Final value: {result}")


def make_unique_value_dict(limits_array):
    unique_limits = get_unique_limits(limits_array)
    unique_integrals_value = calc_unique_integrals(unique_limits)
    result = dict(zip(unique_limits, unique_integrals_value))
    print(f"Limits & value: {result}")
    return result


def calc_unique_integrals(unique_limits):
    value_unique_integrals = []
    for limits in unique_limits:
        to_be_integrated = var_list[-1] ** 0
        for i in range(len(limits) - 1):
            to_be_integrated = sp.integrate(to_be_integrated, (limits[i][0], (limits[1 + i][0], limits[i][1])))
        to_be_integrated = sp.integrate(to_be_integrated, (var_list[2], (var_list[1], 1)))
        result = sp.integrate(to_be_integrated, (var_list[1], (0, 1)))
        value_unique_integrals.append(result)
    return value_unique_integrals


def get_tuple_of_grouped_limits_tuple(limits_array):
    group_size = 4
    return tuple(zip_longest(*(iter(limits_array),) * group_size))


def get_unique_limits(limits_array):
    group_size = 4
    return tuple(set(zip_longest(*(iter(limits_array),) * group_size)))


def get_adjacency_matrix():
    matrix = []
    with open(r"6Graph1.txt", "r") as file:
        for line in file:
            matrix.append([int(x) for x in line.split()])
    adjacency_matrix = [[i + 1] + row for i, row in enumerate(matrix)]
    adjacency_matrix.insert(0, [0, 1, 2, 3, 4, 5, 6])
    return adjacency_matrix


def get_all_permutations(permutation):
    return list(permutations(permutation))


def get_one_limit(primary_node, permutation, overlap_tracker, adjacency_matrix, limit, limits_array):
    # secondary_node: leftmost point, varied until a connection with fixed rightmost point is found.
    for secondary_node in range(primary_node):
        # if position primary_node and secondary node are connected and connection
        # is not overlapped, then upperLimit of primary node position is the position it is connected to,
        # which is secondary_node.
        if adjacency_matrix[permutation[primary_node]][permutation[secondary_node]] and not overlap_tracker[secondary_node]:
            # print(f"UpperLimit integration variable in if   {varList[-primaryNode - 1]} "
            #       f" : {1 + varList[secondary_node]} ")
            limit = 1 + var_list[secondary_node]
            for i in range(secondary_node, primary_node + 1):
                # keeps track of overlapping connections and helps ignore limits generated by overlapping points
                overlap_tracker[i] = 1
            break
        # if the connection between primary and secondary nodes is overlapping then the limit of primary node will
        # be the limit of rightMost limit. This limit is the same as limit calculated in last calculation, that's why we
        # need to use global variables, so that we can access the limit in "if" as well as "else-if" conditional.
        elif overlap_tracker[secondary_node] == 1 and overlap_tracker[primary_node] == 1:
            break
    limits_array.append(([var_list[primary_node], limit]))
    return limit


def get_all_limits(permutation, adjacency_matrix, limits_array):
    overlap_tracker = [0] * len(permutation)
    limit = 1
    for primary_node in range(len(permutation) - 1, 1, -1):
        limit = get_one_limit(primary_node, permutation, overlap_tracker, adjacency_matrix, limit, limits_array)


def main():
    print("Hello mate! Working, Hold on!")

    start_time = time.time()

    adjacency_matrix = get_adjacency_matrix()
    initial_permutation = [1, 2, 3, 4, 5, 6]
    all_permutations = get_all_permutations(initial_permutation)
    limits_array = []
    for perm in all_permutations:
        get_all_limits(perm, adjacency_matrix, limits_array)
    limits_tuple = tuple(map(tuple, limits_array))
    calculate_integrals_sum(limits_tuple)

    print("--- %s seconds ---" % (time.time() - start_time))


main()
